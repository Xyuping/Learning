# ClassLoader

##  java 虚拟机与程序的生命周期

#### java 虚拟机结束生命周期

- 执行了System.exit(int status)方法 ，当status为0时正常退出，非0时异常退出
- 程序正常执行结束
- 程序在执行过程中遇到了异常或错误而异常终止
- 由于操作系统出现错误而导致 java 虚拟机进程中止

## ClassLoader（类加载器）

### 类的加载、连接与初始化

#### 加载

查找并加载类的二进制数据（.class文件）（把.class 文件加载进内存（运行时数据区的方法区内）），然后在堆区创建一个 java.lang.Class对象，用来封装类在方法区的数据结构，并向程序员提供了访问方法区内数据结构的接口

##### 加载.class文件的方式

1. 本地
2. 通过网络下载 java.net 下的 URLClassLoader（URL[] urls）
3. 从 zip，jar 等归档文件中加载.class文件
4. 从专有数据库中提取
5. 将 java 源文件动态编译为,class文件

#### 连接

- 验证:确保被加载的类的正确性（有的用户不是通过 javac 生成的字节码文件，而是通过其他方式例如自己手动生成，不符合规java 虚拟机要求就会出错 ）

> 类文件结构检查（确保类文件遵循java 类文件的固定格式）、语义检查（java 语法）、字节码验证（操作码）、二进制兼容的验证（确保相互引用的类之间协调一致）

- 准备：为类的***静态***变量分配内存（方法区），并将其初始化为***默认值***
- 解析：把类的符号引用转换为直接引用

#### 初始化

为类的静态变量赋予正确的***初始值***

## java程序对类的使用方式（2种）

### 主动使用（6种情况）

1. 创建类的实例 （new 对象）
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（如 Class.forName("daslkj")）
5. 初始化一个类的子类
6. java 虚拟机启动时被标明为启动类的类 （main 方法）

```java
public class Test1 {
	static {
		System.out.println("static");
	}

	public static void main(String[] args) {
		System.out.println("main");
	}
}

=================
    static
    main
```



### 被动使用

除了6中主动使用方式外

> 所有的 java 虚拟机实现必须在每个类或接口被 java 程序 ***首次主动使用*** 时才初始化他们。

## 类加载器

两种类型：java 虚拟机自带、用户自定义

### java 虚拟机自带的类加载器

1. 根类加载器（bootstrap）——c++写的
2. 扩展加载器——java 写的
3. 系统加载器（应用加载器）——java 写的

### 用户自定义

- java.lang.ClassLoader的子类
- 用户可以定义类的加载方法

### 父亲委派机制

父子加载器不是继承关系，而是包装关系。（有可能存在继承、有可能是同一个类的两个对象、）。子加载器包装了父加载器。

定义类加载器：加载该类。

初始类加载器：（包括定义类加载器在内）可以返回该类class对象。

命名空间：每个类加载器都有自己的命名空间，命名空间由该类加载器及其所有附加在其所加载的类组成。同一个命名空间内不会出现类的完整名字（包括包名）相同的两个类，但在不同的命名空间中有可能会出现。